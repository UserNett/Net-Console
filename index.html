<!DOCTYPE html>
<html lang="it">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Tennis for Two — Retro Web (1958)</title>
<style>
:root{
  --green:#9eff9e;
  --dark:#020602;
  --crt-border:#08200a;
  --accent:#7cff7c;
}
*{box-sizing:border-box}
html,body{height:100%}
body{
  margin:0;
  font-family: "Courier New", monospace;
  background: radial-gradient(1000px 500px at 10% 10%, #071407 0%, #000 50%);
  color:var(--green);
  display:flex;
  align-items:center;
  justify-content:center;
  padding:18px;
}
/* CRT frame */
.wrapper{
  width:960px;
  max-width:100%;
  border-radius:12px;
  padding:18px;
  background:linear-gradient(180deg,#041204,#001100);
  border:6px solid var(--crt-border);
  box-shadow:0 18px 60px rgba(0,0,0,0.8), inset 0 0 80px rgba(0,255,0,0.02);
}
.header{display:flex;justify-content:space-between;align-items:center;margin-bottom:12px}
h1{margin:0;font-size:20px;letter-spacing:2px;text-transform:uppercase}
.subtitle{font-size:12px;opacity:.8}
/* menu */
.menu{display:flex;gap:10px;justify-content:center;margin-bottom:12px}
.menu button{background:transparent;border:2px solid rgba(0,180,70,0.95);color:var(--green);padding:10px 14px;border-radius:6px;cursor:pointer;font-weight:700}
.menu button:hover{background:rgba(0,255,120,0.03)}
/* screen */
.screen{background:#000;border-radius:8px;padding:12px;border:1px solid rgba(0,255,0,0.06);position:relative;overflow:hidden}
.canvas-wrap{position:relative;border-radius:6px;padding:8px;background:linear-gradient(180deg, rgba(0,30,0,0.02), rgba(0,0,0,0.02));}
canvas{display:block;width:100%;height:auto;border:1px solid rgba(0,255,0,0.12);background:transparent;filter:contrast(1.05) saturate(.9)}
.scanlines{position:absolute;inset:0;pointer-events:none;background-image:repeating-linear-gradient(transparent, rgba(0,0,0,0.06) 1px, transparent 2px);mix-blend-mode:multiply;opacity:0.95}
.vignette{position:absolute;inset:0;pointer-events:none;background:radial-gradient(ellipse at center, transparent 60%, rgba(0,0,0,0.6) 100%)}
.crt-glow{position:absolute;inset:0;pointer-events:none;background:radial-gradient(circle at 50% 30%, rgba(0,255,150,0.03), transparent 20%)}
/* scoreboard and UI */
.scoreboard{display:flex;justify-content:center;gap:18px;margin:10px 0;font-weight:700}
.scorebox{background:linear-gradient(90deg, rgba(0,40,0,0.18), rgba(0,0,0,0.12));padding:6px 12px;border-radius:6px;border:1px solid rgba(0,255,0,0.08)}
.scorebox span{display:block;font-size:18px}
.hints{font-size:13px;opacity:.9;text-align:center;margin-top:6px}
.controls-row{display:flex;gap:10px;justify-content:center;margin-top:8px;align-items:center}
.power-meter{width:180px;height:14px;border:1px solid rgba(0,255,0,0.12);border-radius:6px;overflow:hidden;background:rgba(0,0,0,0.2)}
.power-fill{height:100%;background:linear-gradient(90deg,var(--accent),#45ff45);width:0%}
/* touch controls */
.touch-controls{display:none;gap:8px;justify-content:center;margin-top:12px;flex-wrap:wrap}
.touch-button{background:linear-gradient(180deg,#003300,#002200);border:2px solid #0f6b28;color:var(--green);padding:10px 12px;border-radius:6px;font-weight:700;user-select:none}
.touch-button:active{transform:translateY(1px)}
/* back button */
.backBtn{display:block;margin:14px auto 0;padding:8px 12px;border-radius:6px;background:transparent;border:2px solid rgba(180,50,50,0.9);color:#ff8080;font-weight:700}
/* mobile */
@media (max-width:720px){
  .touch-controls{display:flex}
  .hints{display:none}
}
/* aiming dashed line */
.aim-canvas{position:absolute;left:0;top:0;pointer-events:none}
/* static canvas */
.static-canvas{position:absolute;inset:0;pointer-events:none;opacity:0;transition:opacity .2s}
</style>
</head>
<body>
<div class="wrapper" role="application" aria-label="Tennis for Two retro">
  <div class="header">
    <div>
      <h1>Tennis for Two</h1>
      <div class="subtitle">Ricreazione fedele — Effetto CRT • Premi per carica</div>
    </div>
    <div style="font-size:12px;opacity:0.8">Web version • 1958 inspired</div>
  </div>

  <div class="menu" id="menu">
    <button onclick="startGame('cpu')">VS COMPUTER</button>
    <button onclick="startGame('multiplayer')">2 GIOCATORI</button>
  </div>

  <div class="screen" id="screen">
    <div class="canvas-wrap">
      <canvas id="gameCanvas" width="800" height="420" aria-label="Campo da tennis retro"></canvas>
      <canvas class="aim-canvas" id="aimCanvas" width="800" height="420"></canvas>
      <div class="scanlines"></div>
      <div class="vignette"></div>
      <div class="crt-glow"></div>
      <canvas class="static-canvas" id="staticCanvas" width="800" height="420"></canvas>
    </div>

    <div class="scoreboard">
      <div class="scorebox">GIOCATORE 1<br><span id="scoreLeft">0</span></div>
      <div class="scorebox">GIOCATORE 2<br><span id="scoreRight">0</span></div>
    </div>

    <div class="controls-row">
      <div class="hints" id="desktopHints">PC: G1 W/S angolo • Tieni A per caricare e rilascia per colpire — G2 Frecce SU/GIU angolo • Tieni L per caricare e rilascia</div>
      <div style="width:8px"></div>
      <div style="display:flex;align-items:center;gap:8px">
        <div style="font-size:12px;opacity:.9">Potenza P1</div>
        <div class="power-meter"><div id="powerP1" class="power-fill"></div></div>
      </div>
      <div style="display:flex;align-items:center;gap:8px">
        <div style="font-size:12px;opacity:.9">Potenza P2</div>
        <div class="power-meter"><div id="powerP2" class="power-fill"></div></div>
      </div>
    </div>

    <div class="touch-controls" id="touchControls">
      <button class="touch-button" id="p1Up">P1 SU</button>
      <button class="touch-button" id="p1Down">P1 GIÙ</button>
      <button class="touch-button" id="p1Hit">P1 CARICA/RILASCIA</button>
      <div style="width:12px"></div>
      <button class="touch-button" id="p2Up">P2 SU</button>
      <button class="touch-button" id="p2Down">P2 GIÙ</button>
      <button class="touch-button" id="p2Hit">P2 CARICA/RILASCIA</button>
    </div>

    <button class="backBtn hidden" id="backBtn" onclick="backToMenu()">MENU PRINCIPALE</button>
  </div>

  <div style="text-align:center;margin-top:10px;font-size:11px;opacity:.8">I comandi touch appaiono sui dispositivi mobili. Mantieni premuto per aumentare la potenza del colpo.</div>
</div>

<script>
/* --- Setup canvases and HiDPI --- */
const canvas = document.getElementById('gameCanvas'), ctx = canvas.getContext('2d');
const aimCanvas = document.getElementById('aimCanvas'), actx = aimCanvas.getContext('2d');
const staticCanvas = document.getElementById('staticCanvas'), sctx = staticCanvas.getContext('2d');

function resizeAll(){
  const ratio = devicePixelRatio || 1;
  const w = canvas.clientWidth || 800, h = canvas.clientHeight || 420;
  [canvas, aimCanvas, staticCanvas].forEach(c=>{
    c.width = Math.floor(w * ratio);
    c.height = Math.floor(h * ratio);
    c.style.width = w + 'px';
    c.style.height = h + 'px';
    const g = c.getContext('2d');
    g.setTransform(ratio,0,0,ratio,0,0);
  });
}
window.addEventListener('resize', resizeAll);
resizeAll();

/* --- Game state --- */
const state = {
  ball:{x:400,y:220,vx:0,vy:0,r:6},
  p1:{angle:45,x:160,y:350},
  p2:{angle:45,x:640,y:350},
  gravity:0.38,
  groundY:380, netX:400, netH:80,
  score:{left:0,right:0},
  ballInPlay:false, lastHit:'', serve:'left'
};
let keys = {}, touchState = {}, gameMode='', raf=null;

/* --- Power charge --- */
let chargeP1 = 0, chargeP2 = 0, chargingP1=false, chargingP2=false;
const maxCharge = 28; // multiplies speed

// update power UI
function updatePowerUI(){
  document.getElementById('powerP1').style.width = Math.round((chargeP1/maxCharge)*100) + '%';
  document.getElementById('powerP2').style.width = Math.round((chargeP2/maxCharge)*100) + '%';
}

/* --- Device controls visibility --- */
function isTouchDevice(){ return ('ontouchstart' in window) || navigator.maxTouchPoints>0; }
function updateControlsVisibility(){
  const tc = document.getElementById('touchControls'), dh = document.getElementById('desktopHints');
  if(isTouchDevice() || window.innerWidth <= 720){ tc.style.display='flex'; dh.style.display='none'; }
  else { tc.style.display='none'; dh.style.display='block'; }
}
updateControlsVisibility();

/* --- Start/back --- */
function startGame(mode){
  gameMode = mode;
  document.getElementById('menu').style.display='none';
  document.getElementById('backBtn').classList.remove('hidden');
  state.score.left = 0; state.score.right = 0; updateScore();
  resetBall(state.serve);
  if(raf) cancelAnimationFrame(raf);
  raf = requestAnimationFrame(loop);
}
function backToMenu(){
  cancelAnimationFrame(raf); raf=null;
  document.getElementById('menu').style.display='flex';
  document.getElementById('backBtn').classList.add('hidden');
}

/* --- Reset ball & static effect --- */
function resetBall(side){
  state.serve = side;
  state.ball.x = (side==='left')?240:560;
  state.ball.y = 200;
  state.ball.vx = 0; state.ball.vy = 0; state.ballInPlay=false; state.lastHit='';
  showStaticBrief();
}
// static visual effect
function showStaticBrief(){
  const w = staticCanvas.width, h = staticCanvas.height;
  sctx.clearRect(0,0,staticCanvas.width,staticCanvas.height);
  const density = 0.03; // fraction of pixels
  const total = Math.floor((w/ (devicePixelRatio||1))*(h/(devicePixelRatio||1)) * density);
  for(let i=0;i<total;i++){
    const x = Math.random()*w, y=Math.random()*h;
    sctx.fillStyle = Math.random()>0.5 ? '#b7ffcf' : '#003300';
    sctx.fillRect(x,y,1,1);
  }
  staticCanvas.style.opacity = 1;
  setTimeout(()=> staticCanvas.style.opacity = 0, 120);
}

/* --- Scoring --- */
function updateScore(){ document.getElementById('scoreLeft').textContent = state.score.left; document.getElementById('scoreRight').textContent = state.score.right; }

/* --- Hit mechanics --- */
function hit(side, power){
  const p = (side==='left')?state.p1:state.p2;
  if(state.ballInPlay && state.lastHit===side) return;
  const rad = p.angle * Math.PI / 180;
  const base = 8; // base speed
  const sp = base + (power || 8);
  const dir = (side==='left')?1:-1;
  state.ball.vx = Math.cos(rad) * sp * dir;
  state.ball.vy = -Math.sin(rad) * sp;
  state.ballInPlay = true; state.lastHit = side;
}

/* --- CPU simple AI --- */
function cpuUpdate(){
  if(!state.ballInPlay && state.serve==='right'){
    setTimeout(()=>{ hit('right', 10+Math.random()*6); }, 400 + Math.random()*300);
  } else if(state.ballInPlay){
    const target = state.ball.y>300?35:55;
    state.p2.angle += (target - state.p2.angle)*0.06;
    if(state.ball.x > state.netX + 60 && Math.abs(state.ball.y - state.groundY) < 110){
      hit('right', 10 + Math.random()*6);
    }
  }
}

/* --- Physics --- */
function physicsStep(){
  if(state.ballInPlay){
    state.ball.x += state.ball.vx; state.ball.y += state.ball.vy; state.ball.vy += state.gravity;
    // ground collision
    if(state.ball.y >= state.groundY){
      state.ball.y = state.groundY;
      state.ball.vy *= -0.56; state.ball.vx *= 0.92;
      if(Math.abs(state.ball.vy) < 1){
        if(state.ball.x < state.netX) state.score.right++; else state.score.left++;
        updateScore(); resetBall(state.ball.x < state.netX ? 'left':'right');
      }
    }
    // net collision
    if(Math.abs(state.ball.x - state.netX) < 8 && state.ball.y > state.groundY - state.netH){
      if(state.ball.x < state.netX) state.score.right++; else state.score.left++;
      updateScore(); resetBall(state.ball.x < state.netX ? 'left':'right');
    }
    // out
    if(state.ball.x < -80 || state.ball.x > canvas.width+80 || state.ball.y > canvas.height+200){
      if(state.ball.x < state.netX) state.score.right++; else state.score.left++;
      updateScore(); resetBall(state.ball.x < state.netX ? 'left':'right');
    }
  }
}

/* --- Drawing helpers --- */
function drawCourt(){
  // green background
  ctx.fillStyle = '#001500'; ctx.fillRect(0,0,canvas.width,canvas.height);
  // ground line
  ctx.strokeStyle = 'rgba(0,255,120,0.22)'; ctx.lineWidth = 2;
  ctx.beginPath(); ctx.moveTo(40,state.groundY); ctx.lineTo(canvas.width-40,state.groundY); ctx.stroke();
  // net
  ctx.beginPath(); ctx.moveTo(state.netX, state.groundY); ctx.lineTo(state.netX, state.groundY - state.netH); ctx.lineWidth = 3; ctx.stroke();
  ctx.fillStyle = 'rgba(0,255,120,0.9)';
  for(let i=0;i<state.netH;i+=8) ctx.fillRect(state.netX-2, state.groundY - i, 4, 2);
}
function drawPlayer(p, flip){
  ctx.fillStyle = 'rgba(0,255,140,0.95)'; ctx.beginPath(); ctx.arc(p.x,p.y,6,0,Math.PI*2); ctx.fill();
  const rad = p.angle * Math.PI/180; const len = 60;
  const ex = p.x + (flip ? -1 : 1) * Math.cos(rad) * len; const ey = p.y - Math.sin(rad) * len;
  ctx.lineWidth = 3; ctx.strokeStyle = 'rgba(0,255,140,0.95)'; ctx.beginPath(); ctx.moveTo(p.x,p.y); ctx.lineTo(ex,ey); ctx.stroke();
  ctx.beginPath(); ctx.arc(ex,ey,8,0,Math.PI*2); ctx.stroke();
}
function drawBall(){
  // trail
  for(let i=4;i>0;i--){
    const t=i/4; ctx.beginPath(); ctx.globalAlpha = 0.12 * t; ctx.fillStyle='rgba(0,255,150,0.9)';
    ctx.arc(state.ball.x - state.ball.vx * i*0.6, state.ball.y - state.ball.vy * i*0.6, state.ball.r,0,Math.PI*2); ctx.fill();
  }
  ctx.globalAlpha = 1;
  ctx.beginPath(); ctx.fillStyle = '#b7ffcf'; ctx.arc(state.ball.x,state.ball.y,state.ball.r,0,Math.PI*2); ctx.fill();
  ctx.strokeStyle='rgba(0,200,100,0.6)'; ctx.stroke();
}
/* draw dashed aiming trajectory based on angle and current charge */
function drawAim(side, charge){
  actx.clearRect(0,0,aimCanvas.width,aimCanvas.height);
  const p = (side==='left')?state.p1:state.p2;
  // starting point near racket end
  const rad = p.angle * Math.PI/180;
  const startX = p.x + (side==='left'?1:-1) * Math.cos(rad) * 60;
  const startY = p.y - Math.sin(rad) * 60;
  // simulate with simple physics steps
  let simX = startX, simY = startY;
  let vx = Math.cos(rad) * (8 + charge) * (side==='left'?1:-1);
  let vy = -Math.sin(rad) * (8 + charge);
  actx.strokeStyle = 'rgba(0,255,120,0.7)'; actx.lineWidth = 1.5; actx.setLineDash([6,6]);
  actx.beginPath(); actx.moveTo(simX, simY);
  for(let i=0;i<180;i++){
    simX += vx; simY += vy; vy += state.gravity*0.8;
    actx.lineTo(simX, simY);
    if(simY > state.groundY) break;
  }
  actx.stroke(); actx.setLineDash([]);
}

/* --- Main render loop --- */
function render(){
  // slight CRT barrel distortion mimic via scaling vertical a bit and overlay glow
  ctx.save(); ctx.clearRect(0,0,canvas.width,canvas.height);
  drawCourt();
  drawPlayer(state.p1, false); drawPlayer(state.p2, true);
  drawBall();
  ctx.restore();
}

/* --- Loop --- */
function loop(ts){
  // charging
  if(chargingP1){ chargeP1 = Math.min(maxCharge, chargeP1 + 0.5); updatePowerUI(); drawAim('left', chargeP1); }
  if(chargingP2){ chargeP2 = Math.min(maxCharge, chargeP2 + 0.5); updatePowerUI(); drawAim('right', chargeP2); }
  // handle input for angles
  if(keys['w']) state.p1.angle = Math.min(85, state.p1.angle + 2);
  if(keys['s']) state.p1.angle = Math.max(5, state.p1.angle - 2);
  if(keys['ArrowUp']) state.p2.angle = Math.min(85, state.p2.angle + 2);
  if(keys['ArrowDown']) state.p2.angle = Math.max(5, state.p2.angle - 2);
  // touch inputs
  if(touchState['p1Up']) state.p1.angle = Math.min(85, state.p1.angle + 2);
  if(touchState['p1Down']) state.p1.angle = Math.max(5, state.p1.angle - 2);
  if(touchState['p2Up']) state.p2.angle = Math.min(85, state.p2.angle + 2);
  if(touchState['p2Down']) state.p2.angle = Math.max(5, state.p2.angle - 2);

  if(gameMode === 'cpu') cpuUpdate();
  physicsStep();
  render();
  raf = requestAnimationFrame(loop);
}

/* --- Input handling --- */
// keyboard
document.addEventListener('keydown', e=>{
  keys[e.key] = true;
  // start charging for p1: 'a'
  if(e.key === 'a' && !chargingP1){ chargingP1 = true; chargeP1 = 0; }
  // start charging for p2: 'l'
  if(e.key === 'l' && !chargingP2){ chargingP2 = true; chargeP2 = 0; }
});
document.addEventListener('keyup', e=>{
  keys[e.key] = false;
  // release hits
  if(e.key === 'a' && chargingP1){ chargingP1 = false; hit('left', Math.round(chargeP1)); chargeP1 = 0; updatePowerUI(); actx.clearRect(0,0,aimCanvas.width,aimCanvas.height); }
  if(e.key === 'l' && chargingP2){ chargingP2 = false; hit('right', Math.round(chargeP2)); chargeP2 = 0; updatePowerUI(); actx.clearRect(0,0,aimCanvas.width,aimCanvas.height); }
});

// touch wiring (press and hold)
function wireTouchButton(id, key, isHit){
  const el = document.getElementById(id);
  if(!el) return;
  const down = (ev)=>{
    ev.preventDefault();
    if(isHit){
      if(key==='p1Hit'){ chargingP1 = true; chargeP1 = 0; }
      if(key==='p2Hit'){ chargingP2 = true; chargeP2 = 0; }
    } else {
      touchState[key] = true;
    }
  };
  const up = (ev)=>{
    ev && ev.preventDefault();
    if(isHit){
      if(key==='p1Hit' && chargingP1){ chargingP1=false; hit('left', Math.round(chargeP1)); chargeP1=0; updatePowerUI(); actx.clearRect(0,0,aimCanvas.width,aimCanvas.height); }
      if(key==='p2Hit' && chargingP2){ chargingP2=false; hit('right', Math.round(chargeP2)); chargeP2=0; updatePowerUI(); actx.clearRect(0,0,aimCanvas.width,aimCanvas.height); }
    } else {
      touchState[key] = false;
    }
  };
  el.addEventListener('touchstart', down); el.addEventListener('mousedown', down);
  el.addEventListener('touchend', up); el.addEventListener('mouseup', up);
  el.addEventListener('mouseleave', up); el.addEventListener('touchcancel', up);
}
wireTouchButton('p1Up','p1Up', false);
wireTouchButton('p1Down','p1Down', false);
wireTouchButton('p1Hit','p1Hit', true);
wireTouchButton('p2Up','p2Up', false);
wireTouchButton('p2Down','p2Down', false);
wireTouchButton('p2Hit','p2Hit', true);

// basic pointer support: clicking near racket toggles charge/hit (optional)
canvas.addEventListener('pointerdown', (e)=>{
  const rect = canvas.getBoundingClientRect();
  const x = (e.clientX - rect.left);
  // decide side
  if(x < rect.width/2){ chargingP1 = true; chargeP1 = 0; } else { chargingP2 = true; chargeP2 = 0; }
});
canvas.addEventListener('pointerup', (e)=>{
  const rect = canvas.getBoundingClientRect();
  const x = (e.clientX - rect.left);
  if(x < rect.width/2 && chargingP1){ chargingP1=false; hit('left', Math.round(chargeP1)); chargeP1=0; updatePowerUI(); actx.clearRect(0,0,aimCanvas.width,aimCanvas.height); }
  if(x >= rect.width/2 && chargingP2){ chargingP2=false; hit('right', Math.round(chargeP2)); chargeP2=0; updatePowerUI(); actx.clearRect(0,0,aimCanvas.width,aimCanvas.height); }
});

// initial draw
resizeAll(); updateControlsVisibility(); render();

window.startGame = startGame; window.backToMenu = backToMenu;
</script>
</body>
</html>
